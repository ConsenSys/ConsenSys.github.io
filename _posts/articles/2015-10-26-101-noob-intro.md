---
layout: post
title: "A 101 Noob Intro to Programming Smart Contracts on Ethereum"
excerpt: "For super noobs."
categories: articles
tags: [101, noobs, truffle]
author: eva_shon_with_help
share: true
image:
  feature: 
  credit: 
  creditlink:
---
*Some people say Ethereum is too logic-heavy and hard to use, but here’s a write-up to give you a feel for building smart contracts and applications with it. Tools, wallets, applications and the ecosystem are still in development and it’ll get easier!*

* **[Part I](#parti)** is an overview of key terms and discusses **[Ethereum Clients and Smart Contract Languages](#clients_languages)**.
* **[Part II](#partii)** discusses overall workflow and some current **DApp Frameworks and Tools** and
* **[Part III](#partiii)** is a the **Programming Part**, a quick walkthrough of writing tests for a smart contract and building a DApp using Truffle.


<a name="parti"></a>

## Part I. Intro

If you’re new to *all* this cryptocurrency stuff, including Bitcoin and how it works, check out the first couple chapters of Andreas Antonopoulos' [Bitcoin Book](https://github.com/aantonop/bitcoinbook) to dip your toe in the water. Then head over to the [Ethereum Whitepaper](https://github.com/ethereum/wiki/wiki/White-Paper).

If you start getting into some murky sections and would rather build something to get familiar first, then just read on. You don’t have to understand all the crypto economic computer science to start building, and a lot of that paper is about Ethereum’s improvements over Bitcoin’s architecture.

#### Starter Tutorials

The official place to start is Ethereum's [Solidity tutorial](https://ethereum.github.io/solidity/). Another good place to start with smart contracts (where I started) is [dappsForBeginners](https://dappsforbeginners.wordpress.com), although it might be outdated. Another good place is at [ethereum.org/greeter](https://ethereum.org/greeter) and the follow-up token and crowdsale tutorials. Those are good for learning Solidity.

The goal of this write-up is to introduce some basic developer tools that make starting out with Ethereum, smart contracts and building DApps (decentralized apps) easier, and to try to explain the overall flow of what’s going on. This is from my (still-noob) perspective and with much help from the cool developers at ConsenSys.

#### Basic Concepts

It’d be good to know some of these terms: 

***Public Key Cryptography.***  Alice has a public key and private key. She can use her private key to create a digital signature, and Bob can use Alice's public key to verify that a signature is really from Alice's private key, i.e., really from Alice. When you create an Ethereum or Bitcoin wallet the long ‘0xdf...5f’ address is a public key and the private key is stored somewhere. A Bitcoin wallet service like Coinbase stores your wallet’s complementary private key for you, or you can store it yourself. If you lose your private key for a wallet with funds on Bitcoin or Ethereum, you’ll lose all your funds forever, so it’s good to back up your keys. It hurts to learn this the hard way, although plenty of people have done it.

***Peer-to-Peer Networking.***  Like BitTorrent, all Ethereum nodes are peers in a distributed network, there’s no centralized server. [In the future, there’ll be hybrid semi-centralized services for Ethereum as a convenience to users and developers, more on that later.]

***Blockchain.***  Like a global ledger or simple database of all transactions, the entire history of all transactions on the network.

***Ethereum Virtual Machine.***  So you can write more powerful programs than on top of Bitcoin. It refers to the blockchain, what executes smart contracts, everything.

***Node.***  Using this to mean you can run a node and through it read and write to the Ethereum blockchain, i.e., use the Ethereum Virtual Machine. A full node has to download the entire blockchain. Light nodes are possible but in the works, see the Ethereum whitepaper.

***Miner.***  A node on the network that mines, i.e., works to process blocks on the blockchain. You can see a partial list of live Ethereum miners here: [stats.ethdev.com](https://stats.ethdev.com/).

***Proof of Work.***  Miners compete to do some math problem. The first one to solve the problem (the next block on the Blockchain) wins a reward: some ether. Every node then updates to that new block. Every miner wants to win the next new block so are incentivized to keep up to date and have the one true blockchain everybody else has, so the network always achieves consensus. [Note: Ethereum is planning to move to a Proof of Stake system without miners eventually, but that’s beyond noob scope.]

***Ether.***  Or ETH for short. It’s a real digital currency you can buy and use! See [this chart](https://poloniex.com/exchange#usdt_eth). At the time of writing, 1 ETH is worth about 65 cents in USD.

***Gas.***  Running and storing things on Ethereum costs small amounts of ether. Keeps things efficient.

***DApp.***  Decentralized App, what applications using smart contracts are called in the Ethereum community. The goal of a DApp is (well, should be) to have a nice UI to your smart contracts plus any extra niceties like IPFS (a neat way to store and serve stuff in a decentralized network, unrelated to Ethereum but a kindred spirit). While DApps can be run from a central server if that server can talk to an Ethereum node, they can also be run locally on any Ethereum node peer.

For another noob angle on some of the concepts above here’s a good read: [Just Enough Bitcoin for Ethereum](https://medium.com/@ConsenSys/time-sure-does-fly-ed4518792679).


<a name="clients_languages"></a>

## Ethereum Clients, Smart Contract Languages

You don’t have to run an Ethereum node to write and deploy smart contracts. See Browser-based IDEs and APIs below. But if you’re learning, run an Ethereum node, it’s good to get to know as a basic component and not hard to set up.

#### Clients for Running an Ethereum Node

Ethereum has several different client implementations (meaning ways to run a node to interact with the Ethereum network) including C++, Go, Python, Java, Haskell, etc. Why? Different strokes for different folks (like how the Haskell one is supposedly mathematically verifiable), and it improves the security and ecosystem of Ethereum to have so many.

At the time of writing, I’ve been using geth, the Go language one (go-ethereum) and on other days a tool called testrpc that uses the Python client, pyethereum. The examples will involve those tools.

[Sidebar: I’ve also tried the C++ one and still use its ethminer component for mining along with geth as the node, so different pieces can work together. Sidebar on Mining: Mining can be fun, sort of like having a houseplant you tend to, and another way to learn about the ecosystem....even if the price of ETH right now is not worth the local electricity costs of mining.]

***Interactive Console.*** Once you have a node using one of the clients, you can sync with the blockchain, create wallets and send and receive real ether. One way to do that with geth is through the [JavaScript console](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console). Another way is via [JSON RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC) (remote procedure calls) using a command like cURL for getting stuff via URLs. However the goal of this article is to walk you through a DApp development scenario so let’s just move on. But these tools are good to remember for debugging, configuring nodes and using a wallet via command line.

***Running a node on a test network.*** If you install geth and run it on the live network, it will take a while to download the entire blockchain and sync with the network. (You can check that it’s synced by seeing that you have the latest block which is listed at the top of stats.ethdev.com and comparing that number to the block number output by your client node.)

However to run smart contracts on the live network you’d have to cough up some real ether. Instead there are ways to run clients on a local testnet for for free. They won’t download the full blockchain and will create a private instance of the network with its own blockchain, so faster to use for development.

***testrpc.*** One way of getting a testnet running is using testrpc. Testrpc will create a bunch of pre-funded accounts for you that will be listed when it starts up. Here's the [Eth-testrpc github repo](https://github.com/ConsenSys/eth-testrpc) but it can be installed via command line using pip. (Will review everything you need to install again in the tutorial part later.)

Testrpc is also super fast, so easier to develop and test with. Start with testrpc. When your contracts are in good shape, move to geth on a testnet, which can be started by specifying a networkid like: `geth --networkid “12345”`

Let’s talk about programming languages next, then we can dive into actually coding stuff.



#### Programming Languages for Smart Contracts

***Just use Solidity.*** To write smart contracts there are a few different languages: Solidity, which is like JavaScript and has .sol as a file extension, Serpent, Python-like with extension .se, and a 3rd, LLL, based on Lisp. Serpent was popular a while back but Solidity is the most popular right now and is more robust, so just use Solidity. You prefer Python? Use Solidity.

***solc Compiler.*** After writing a contract in Solidity, use solc to compile it. It’s from the C++ libraries (different implementations complementing each other again) which can be [installed here](https://github.com/ethereum/webthree-umbrella/wiki). [If you don't want to install solc you can also just use a browser-based compiler like the [Solidity real-time compiler](https://chriseth.github.io/browser-solidity/) or [Cosmo](http://cosmo.to/), but the programming part of this tutorial will assume you have solc installed.]

[Note: Ethereum’s libraries are undergoing active development and sometimes things get out of sync with new versions. Make sure you have the latest dev version. Or make sure you have a stable version. Ask in the Ethereum Gitter’s on Github or forums.ethereum.org what version people are using if things that used to work stop working.]

***web3.js API.*** Once a contract is compiled with solc and sent to the network, you can call it using the Ethereum [web3.js JavaScript API](https://github.com/ethereum/wiki/wiki/JavaScript-API) and build web apps that interact with contracts. (No need to install this yet, read up on DApp Frameworks below first.) 

So Solidity and web3.js API: 2 basic tools for coding smart contracts and interacting with them to build DApps.


<a name="partii"></a>

## Part II. DApp Frameworks, Tools and Workflow

<a name="workflow"></a>

#### Workflow for Deploying Smart Contracts

The workflow is:

1. Start an **Ethereum node** (e.g. geth or testrpc)
2. **Compile** your Solidity smart contract using solc => get back the binary
3. **Deploy** your compiled contract to the network. (This step costs ether and signs the contract using your node’s default wallet address, or you can specify another address.)
=> get back the contract’s blockchain address and ABI (a JSON-ified representation of
your compiled contract’s variables, events and methods that you can call)
4. **Call** stuff in the contract using web3.js’s JavaScript API to interact with it (This step may cost ether depending on the type of invocation.)

This workflow is depicted in the diagram below in greater detail:

<figure>
	<img src="{{site.url}}/images/front-end.png" alt="front-end workflow">
</figure>
	
Note: You could build a DApp that provides a UI for users to deploy a contract then use it (Steps 1 or 4). Or your DApp could assume the contract’s already been deployed (common) and start the UI flow from there (Step 6).

<a name="dapp_frameworks_tools"></a>

***DApp-building Frameworks.*** You can do all these steps with just the tools mentioned above, but some helpful devs have created DApp frameworks to make development easier. The one that got me started is [Truffle](https://github.com/ConsenSys/truffle). (Before Truffle I watched a group of smart student interns last summer code stuff for a sleepless hackathon and shrank back in fear. Then Truffle came along and did a lot of the nitty gritty stuff in the diagram above for you, so you can start writing, compiling, deploying and testing smart contracts right away.) Another very similar framework for building and testing DApps is [Embark](https://iurimatias.github.io/embark-framework). Between those two, I’ve only used Truffle, but there are very successful DApp devs in both camps.

Other stacks DApp devs use include web3.js + [Meteor](https://www.meteor.com/) which is a general webapp framework (The [ethereum-meteor-wallet](https://github.com/ethereum/meteor-dapp-wallet) repo has a good starter example, and [SilentCiero on github](https://github.com/SilentCicero) is building a lot of Meteor integrations with web3.js and DApp boilerplates). I've downloaded and run cool DApps that do things this way. There’ll be some interesting discussion of all of these tools and best practices for building DApps at [Ethereum’s ÐΞVCON1 conference](devcon.ethereum.org) Nov. 9-13th (which will also be streamed or on youtubed).

***APIs.*** [BlockApps.net](http://blockapps.net) is creating a REST API for DApps based on a Haskell node they run as a centralized service to save you the trouble of running a local Ethereum node. This departs from the completely decentralized model of DApps but is useful when running an Ethereum node locally isn’t realistic. For example if you want to serve your DApp to users who won’t be running local nodes either and reach a wider audience with just a web browser or mobile device. BlockApps is developing a command line tool called [bloc](https://github.com/blockapps/bloc) that can be used after creating a developer account with them.

***If users have to run a local Ethereum node to use DApps isn't that a dealbreaker?*** Like BlockApps there are a range of tools in development so this won't be. [Metamask](https://metamask.io/), [AlethZero or AlethOne](https://github.com/ethereum/webthree-umbrella/releases/tag/1.0rc2) and a [LightWallet](https://github.com/ConsenSys/eth-lightwallet) ConsenSys is building are ways to make running a node easy, and light (SPV) nodes, sharding are in the works or planned. It's a P2P ecosystem but can involve hybrid architectures.

#### Smart Contract IDEs

***IDEs.***There’s a [Mix IDE](https://github.com/ethereum/wiki/wiki/Mix:-The-DApp-IDE) for writing contracts put out by Ethereum. Haven’t tried it but will soon.

***Browser-based IDEs.*** There’s a browser-based [Solidity real-time compiler](https://chriseth.github.io/browser-solidity) just for compiling smart contracts. You can  point your local node at this hosted instance by opening up a port (You should trust the site and not have your life savings in ether on your local node for that). Another browser-based IDE is [Cosmo](http://cosmo.to). They’re a fast way to get started compiling your smart contracts. But once your contract is working ok it’s nice to use a framework for adding a UI and packaging it all up as a DApp, which is what Truffle does and will be in the tutorial part later.

Another powerful enterprise-y browser IDE is going to be launched soon by [Ether.Camp](http://frontier.ether.camp). Their IDE comes with a sandbox test network with a GUI for testing (instead of writing tests manually as shown in the tutorial later) as well as a sandbox network explorer at [test.ether.camp](http://test.ether.camp). When you’re ready to deploy your contract for semi-real, using their testnet can a good way to confirm your smart contract’s working as expected on a closer-to-real testbed. The same explorer for the live Ethereum network is at [frontier.ether.camp](http://frontier.ether.camp/) and it shows details about every transaction ever. Ether.Camp’s IDE is invite-only for eager guinea pigs at time of writing but will be launched soon. 

***Sample Contracts.*** Search github for DApp repos and .sol files to see what cool stuff people do and how. A big list of DApps with repos is also here: [dapps.ethercasts.com](http://dapps.ethercasts.com), although some list details a little out of date. [Ether.fund/contracts](http://ether.fund/contracts) also has some examples of Solidity and Serpent contracts people have written, but not sure if these have been tested or verified for correctness.

<a name="partiii"></a>
<a name="programming_part"></a>

## Part III. The Programming Part, Finally

#### Testing in Truffle

[Truffle](https://github.com/consensys/truffle) is great for test-driven development of smart contracts which is highly recommended to maintain sanity when you’re starting to learn how things work. It’s also useful as a way to learn to write promises in JavaScript, i.e., deferred and asynchronous callbacks. Promises are like "do this, then when that comes back, do that, and when that comes back, do this other thing...and we don’t want to be kept waiting while all that’s going on, ok?" Truffle uses a JS promises framework called [Pudding](https://github.com/ConsenSys/ether-pudding) on top of web3.js (so it installs web3.js for you too).

***Transaction times.***  Promises are extremely useful for DApps because transactions need to be mined into the blockchain (takes 12-15 seconds in Ethereum). Even if they don’t seem to take that long on a test network it may take longer on the live network, or to find out it didn’t happen (e.g. your transaction could have ran out of gas, or was mined into a block that’s been orphaned).

So let’s copy a simple smart contract and write a test for it. 

#### Using Truffle

Make sure you have 1. [solc](https://github.com/ethereum/webthree-umbrella/wiki) installed and 2. [testrpc](https://github.com/ConsenSys/eth-testrpc). (For testrpc you’ll need python and [pip](https://pip.pypa.io/en/stable/installing/). If you’re new to python, to install it you may also need a [virtualenv](http://docs.python-guide.org/en/latest/dev/virtualenvs/), a way to keep python libraries separate on a single computer.)

Install 3. [Truffle](https://github.com/ConsenSys/truffle) (You can do this using NodeJS’s npm: `npm install -g truffle`, the `-g` may require sudo).  `truffle list` will list all truffle commands. Create and change into a new project directory and do `truffle init` in a terminal window. This will create this directory structure:
<figure class="third">
	<img src="{{site.url}}/images/truffle-directories.png" alt="truffle directories">
</figure>

Start a client node in a new console window by running `testrpc`: 
<figure class="half">
	<img src="{{site.url}}/images/testrpc-start.png" alt="testrpc startup screen">
</figure>

In the first truffle console window, now type `truffle deploy`. This will deploy the Example contract `truffle init` created. Any errors messages you may have will show up in the testrpc console window or the truffle window.

As you're developing you can do `truffle compile` to make sure your contracts compile, `truffle deploy` to compile and deploy it to the network, and `truffle test` will run your smart contract tests.

But let’s start with getting to `truffle test` with a real example.



#### First Contract, First Test

Here’s a Solidity contract for a Conference where registrants can buy tickets, and the organizer can set a maximum quota of attendees as well as provide refunds.

{% highlight javascript %}

contract Conference {
	address public organizer;
	mapping (address => uint) registrantsPaid;
	uint public numRegistrants;
	uint public quota;

	event Deposit(address _from, uint _amount); // so you can log these events
	event Refund(address _to, uint _amount); 

	function Conference() {	// Constructor
		organizer = msg.sender;		
		quota = 500;
		numRegistrants = 0;
	}
	function buyTicket() public returns (bool success) {
		if (numRegistrants >= quota) { return false; }
		registrantsPaid[msg.sender] = msg.value;
		numRegistrants++;
		Deposit(msg.sender, msg.value);
		return true;
	}
	function getRegPaid(address _address) public returns (uint amtPaid) {
		return registrantsPaid[_address];
	}
	function changeQuota(uint newquota) public {
		if (msg.sender != organizer) { return; }
		quota = newquota;
	}
	function refundTicket(address recipient, uint amount) public {
		if (msg.sender != organizer) { return; }
		if (registrantsPaid[recipient] == amount) { 
			address myAddress = this;
			if (myAddress.balance >= amount) { 
				recipient.send(amount);
				registrantsPaid[recipient] = 0;
				numRegistrants--;
				Refund(recipient, amount);
			}
		}
	}
	function destroy() { // so funds not locked in contract forever
		if (msg.sender == organizer) { 
			suicide(organizer); // send funds to organizer
		}
	}
}

{% endhighlight %} 

Let’s deploy this. 

##### Steps:
<figure>
	<img src="{{site.url}}/images/truffle-steps.png" alt="truffle directories">
</figure>

[Note: At time of writing I have solc 0.1.3+ (installed via brew), Truffle v0.2.1, Eth-testrpc v0.1.18 (using a venv) on Mac OS X 10.10.5.]

#### Deploying the Contract

***Create a new smart contract.*** Copy-paste the Conference contract into `contracts/Conference.sol`. Then in the file `config/app.json`, edit the “deploy” array to include “Conference”.

***Start testrpc.*** Start testrpc via `testrpc` if its not already running.

(If you’re using [geth](https://github.com/ethereum/go-ethereum/), this line was working for me:

{% highlight javascript %}
geth --rpc --rpcaddr="0.0.0.0" --rpccorsdomain="*" --mine --unlock='0 1' --verbosity=5 --maxpeers=0 --minerthreads='4'  --networkid '12345'
{% endhighlight %}

This unlocks two accounts. 1. You may need to enter the passwords to both accounts after the geth console starts up. 2. You may also need a [test-genesis.json](https://github.com/ethereum/go-ethereum/wiki/Connecting-to-the-network#custom-networks) file with both accounts funded under 'alloc'.)

***Compile or Deploy.*** Run `truffle compile` to see if it compiles, or just do `truffle deploy` to compile and deploy at once. This will add the deployed contract’s address and ABI (in config/development/contracts.json), which is what `truffle test` and `truffle build` will pull in information from later to interact with the contract. 

***Errors?*** Did that compile? Errors messages may show up in the testrpc console or the truffle console.

***Redeploy after restarting a node!***  If you stop your testrpc node, remember to redeploy the contracts using `truffle deploy` before trying to use them again. Each time testrpc restarts its a blank slate blockchain.




#### Analyzing the Contract

Let’s start with the variables at the top of the smart contract:

{% highlight javascript %}
address public organizer;
mapping (address => uint) registrantsPaid;
uint public numRegistrants;
uint public quota;
{% endhighlight %} 

***address.*** The first variable is the ethereum address of the organizer, or owner, of this contract. This is set when the “Conference” constructor is called.

***uint.*** An unsigned integer.

***public.*** Means it can be called from outside the contract. A private modifier would mean it can only be called from within the contract (or by derived contracts). If you’re trying to call a variable from a test make sure its public.

***Mappings or Arrays.*** Before Solidity added support for arrays, mappings like `mapping (address => uint)` were used. This could also be written as `address registrantsPaid []` but mappings have a smaller footprint. This mapping will be used to store how much each registrant (represented by their wallet address) has paid so they can get refunds later on.

***More on addresses.*** Your client node (i.e., geth or testrpc in these examples) can have one or more accounts. In testrpc, on startup an array of 10 “Available Addresses” are displayed:

<figure class="half">
	<figcaption><strong>testrpc Accounts:</strong></figcaption>
	<img src="{{site.url}}/images/testrpc-accounts.png" alt="testrpc accounts">
</figure>

The first one is default for calling contracts, `accounts[0]`. So if you want the contract owner/organizer to be `accounts[0]`, in JavaScript you can call the constructor this way:

{% highlight javascript %}
Conference.new({ from: accounts[0] });
{% endhighlight %} 

***Owner address vs. Contract address.*** Your deployed contract also has its own contract address (different from the organizer/owner) on the blockchain that you can see in the bottom of `config/development/contracts.json` after `truffle deploy`. This address is accessible in a Solidity contract using `this`, as used inside the refundTicket function in the contract: `address myAddress = this;`

***Suicide, a good thing in Solidity.*** Funds sent to the contract are held in the contract itself. In the destroy function above funds are finally released to the organizer set in the constructor. `suicide(organizer);` does this. Without it, funds can end up locked in the contract forever (somebody on reddit lost some ether this way), so make sure to include that method if your contract collects funds!

If you want to simulate another user or counterparty (e.g. simulate a buyer if you’re a seller), you can use another address from the accounts array. To buy a ticket as a different user, accounts[1], use it in the `from` field:

{% highlight javascript %}
conference.buyTicket({ from: accounts[1], value: some_ticket_price_integer });
{% endhighlight %} 

***Some Function Calls can be Transactions.*** Function calls that change the state of the contract (modify values, add records, etc.) are **transactions** and have implicit sender and value. So inside curly braces `{ from: ___, value: ___ }` can be specified in a web3.js function call to sending funds to a function from a wallet address. On the Solidity end, you can retrieve these values using the implicit msg.sender and msg.value:

{% highlight javascript %}
function buyTicket() public {
	...
	registrantsPaid[msg.sender] = msg.value;
	...
}
{% endhighlight %} 

***Events.*** `Deposit` and `Send` in the contract are events that can be logged in the Ethereum Virtual Machine logs. They don’t actually do anything, but are good practice for keeping track that a transaction has happened.

Okay, let’s write a test for this smart contract to make sure it works.


#### Writing a Test

In your project folder’s `test/` directory rename the example.js test file to conference.js. Modify all instances of “Example” to “Conference”.

{% highlight javascript %}
contract(Conference, function(accounts) {
  it("should assert true", function(done) {
    var conference = Conference.at(Conference.deployed_address);
    assert.isTrue(true);
    done();   // stops tests at this point
  });
});
{% endhighlight %}

On running `truffle test` from the project’s root directory you should see the test pass. In the test above truffle gets the contract’s address on the blockchain from `Conference.deployed_address`.

Let’s write a test to initialize a new Conference and check that the initial variables are being set correctly. Replace the test in conference.js with this one:

{% highlight javascript %}
contract(Conference, function(accounts) {
  it("Initial conference settings should match", function(done) {
    var conference = Conference.at(Conference.deployed_address);  
    // same as previous example up to here
    Conference.new({ from: accounts[0]  })
    .then(function(conference) {
    	conference.quota.call().then(
    		function(quota) {
    		 assert.equal(quota, 500, "Quota doesn't match!"); 
    		}).then( function() {
    			return conference.numRegistrants.call();
    		}).then( function(num) {
    			assert.equal(num, 0, "Registrants should be zero!");
    			return conference.organizer.call();
    		}).then( function(organizer) {
    			assert.equal(organizer, accounts[0], "Owner doesn't match!");
    			done();   // to stop these tests earlier, move this up
    		}).catch(done);
    	}).catch(done);
     });
    });
{% endhighlight %}

***Constructor.*** As mentioned earlier, `Conference.new({ from: accounts[0]  })` instantiates a new Conference by calling the contract’s constructor. That’ll return a contract object (conference).

***Promises.*** That's what those then and return’s above are. What’s going on above might start to look like a deeply nested function call chain like:

{% highlight javascript %}
conference.numRegistrants.call().then(
  function(num) {
  	assert.equal(num, 0, "Registrants should be zero!");
  	conference.organizer.call().then(
  	 function(organizer) {
     		assert.equal(organizer, accounts[0], "Owner doesn't match!");
     		}).then(
     			function(...))
     				}).then(
     					function(...))
  					// Because this would get hairy...
 {% endhighlight %}


Promises allow this to be flattened to minimize nesting, allow for calls to return asynchronously and help simplify the syntax of writing “on success do this” vs. “on failure do that”. Web3.js provides callbacks for asynchronous requests ([docs](https://github.com/ethereum/wiki/wiki/JavaScript-API#using-callbacks)) so you don’t have to wait for transactions to complete to do stuff in the front-end. (Truffle uses a promises framework wrapper to web3.js called [Pudding](https://github.com/ConsenSys/ether-pudding), based on the framework [Bluebird](http://ricostacruz.com/cheatsheets/bluebird.html), which also has advanced promise features.) 

***call().*** Use this to check the values of variables as in `conference.quota.call().then(...`. Solidity docs say this is a “message call” which is  1. not mined and so 2. doesn’t have to be from an account/wallet (therefore it’s not signed with an account holder’s private keys). Transactions on the other hand, are mined, have to be from an account (i.e., signed), and are recorded on the blockchain. Modifying any value in a contract is a transaction. Just checking a variable value is not. So don’t forget to add call() when calling variables! Crazy things can happen. [Also, if you’re trying to call a variable and having problems make sure its public.]

Call() can also be used to call functions that are not transactions. If they are meant to be transactions and you try to call() them, they won't execute as transactions on the blockchain.

***assert.*** Standard JS testing assertion (if you type ‘asserts’ plural by accident truffle will have errors and you won’t know what’s going on), see the [Chai docs](http://chaijs.com/api/assert/) for other types of assertions but `assert.equal` is usually all you need.

Run `truffle test` again to make sure that works for you.

More to come... will finish adding stuff soon.
